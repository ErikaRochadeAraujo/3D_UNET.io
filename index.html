<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisador de Resson√¢ncia Magn√©tica - IA</title>
    
    <!-- Bibliotecas necess√°rias -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .upload-btn-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
            margin: 20px 0;
        }

        .upload-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .upload-btn-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .status-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .status-text {
            font-size: 1.1em;
            font-weight: 500;
            color: #495057;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-top: 20px;
            border: 2px dashed #dee2e6;
            min-height: 150px;
        }

        .results-title {
            font-size: 1.4em;
            font-weight: bold;
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }

        .result-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .result-label {
            font-weight: bold;
            color: #495057;
        }

        .result-value {
            font-size: 1.1em;
            color: #28a745;
            margin-left: 10px;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border-left-color: #dc3545;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }

        .info-section {
            background: #e3f2fd;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #2196f3;
        }

        .info-title {
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 10px;
        }

        .info-text {
            color: #424242;
            line-height: 1.6;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .main-card {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Analisador de Resson√¢ncia Magn√©tica</h1>
            <p>An√°lise inteligente de imagens m√©dicas usando IA</p>
        </div>

        <div class="main-card">
            <div class="upload-section">
                <h2>üìÅ Upload do Arquivo NIfTI</h2>
                <p>Selecione um arquivo de resson√¢ncia magn√©tica (.nii ou .nii.gz) para an√°lise</p>
                
                <div class="upload-btn-wrapper">
                    <button class="upload-btn">
                        üì§ Escolher Arquivo .nii
                    </button>
                    <input type="file" id="nii-upload" accept=".nii,.nii.gz">
                </div>
                
                <div class="progress-bar" id="progress-bar" style="display: none;">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
            </div>

            <div class="status-section">
                <div class="status-text" id="status">
                    ü§ñ Carregando modelo de IA...
                </div>
            </div>

            <div class="results-section" id="results-section">
                <div class="results-title">üìä Resultados da An√°lise</div>
                <div id="results-content">
                    <p style="text-align: center; color: #6c757d; font-style: italic;">
                        Os resultados da an√°lise aparecer√£o aqui ap√≥s o upload do arquivo.
                    </p>
                </div>
                <!-- Adicione este canvas para a visualiza√ß√£o da segmenta√ß√£o -->
                <canvas id="segmentation-canvas" style="width: 100%; height: auto; border: 1px solid #ccc; margin-top: 20px;"></canvas>
            </div>
        </div>

        <div class="info-section">
            <div class="info-title">‚ÑπÔ∏è Informa√ß√µes Importantes</div>
            <div class="info-text">
                <p><strong>Formatos aceitos:</strong> .nii, .nii.gz (formato NIfTI)</p>
                <p><strong>Dimens√µes esperadas:</strong> O modelo foi treinado para imagens de 128x128 pixels</p>
                <p><strong>Processamento:</strong> A an√°lise √© realizada localmente no seu navegador</p>
                <p><strong>Privacidade:</strong> Seus dados n√£o s√£o enviados para nenhum servidor externo</p>
            </div>
        </div>
    </div>

    <script>
        // Fun√ß√£o para ler o cabe√ßalho NIfTI manualmente
        function readNiftiHeader(buffer) {
            const dataView = new DataView(buffer);
            const littleEndian = true; // NIfTI √© geralmente little-endian

            // Verifica√ß√£o b√°sica da magic number (n+1 ou ni1)
            const magic = String.fromCharCode(dataView.getUint8(348), dataView.getUint8(349), dataView.getUint8(350), dataView.getUint8(351));
            if (magic !== 'n+1' && magic !== 'ni1') {
                throw new Error('Arquivo NIfTI inv√°lido: magic number incorreto.');
            }

            const dims = [];
            for (let i = 0; i < 8; i++) {
                dims.push(dataView.getInt16(40 + i * 2, littleEndian));
            }

            const datatypeCode = dataView.getInt16(70, littleEndian);
            const bitpix = dataView.getInt16(72, littleEndian);
            const voxOffset = dataView.getFloat32(108, littleEndian);

            return {
                dims: dims,
                datatypeCode: datatypeCode,
                bitpix: bitpix,
                voxOffset: voxOffset
            };
        }

        // Fun√ß√£o para ler os dados da imagem NIfTI manualmente
        function readNiftiImage(header, buffer) {
            const dataView = new DataView(buffer);
            const littleEndian = true;

            const imageOffset = header.voxOffset;
            const numVoxels = header.dims[1] * header.dims[2] * header.dims[3];
            const bytesPerVoxel = header.bitpix / 8;

            let imageData;

            // Suporte a alguns tipos de dados comuns (Float32, Int16, Uint8)
            switch (header.datatypeCode) {
                case 16: // DT_INT16
                    imageData = new Int16Array(buffer, imageOffset, numVoxels);
                    break;
                case 64: // DT_FLOAT32
                    imageData = new Float32Array(buffer, imageOffset, numVoxels);
                    break;
                case 2: // DT_UINT8
                    imageData = new Uint8Array(buffer, imageOffset, numVoxels);
                    break;
                default:
                    throw new Error(`Tipo de dado NIfTI n√£o suportado: ${header.datatypeCode}`);
            }

            return imageData;
        }

        // Elementos da interface
        const inputArquivo = document.getElementById("nii-upload");
        const statusDisplay = document.getElementById("status");
        const resultsContent = document.getElementById("results-content");
        const progressBar = document.getElementById("progress-bar");
        const progressFill = document.getElementById("progress-fill");
        const segmentationCanvas = document.getElementById("segmentation-canvas");
        const ctx = segmentationCanvas.getContext("2d");

        // Vari√°veis globais
        let modelo = null;
        let modeloCarregado = false;

        // Fun√ß√£o para atualizar o status
        function atualizarStatus(mensagem, tipo = "info", mostrarLoading = false) {
            const loading = mostrarLoading ? "<span class=\"loading\"></span>" : "";
            statusDisplay.innerHTML = loading + mensagem;
            
            statusDisplay.parentElement.classList.remove("error", "success");
            
            if (tipo === "error") {
                statusDisplay.parentElement.classList.add("error");
            } else if (tipo === "success") {
                statusDisplay.parentElement.classList.add("success");
            }
        }

        // Fun√ß√£o para atualizar a barra de progresso
        function atualizarProgresso(porcentagem) {
            if (porcentagem > 0) {
                progressBar.style.display = "block";
                progressFill.style.width = porcentagem + "%";
            } else {
                progressBar.style.display = "none";
            }
        }

        // Fun√ß√£o para carregar o modelo
        async function carregarModelo() {
            try {
                atualizarStatus("ü§ñ Carregando modelo de IA...", "info", true);
                atualizarProgresso(20);
                
                modelo = await tf.loadLayersModel("./modelo_web/model.json");
                
                atualizarProgresso(100);
                atualizarStatus("‚úÖ Modelo carregado com sucesso! Selecione um arquivo .nii para an√°lise.", "success");
                modeloCarregado = true;
                
                console.log("Modelo carregado:", modelo);
                console.log("Formato de entrada esperado:", modelo.inputs[0].shape);
                console.log("Formato de sa√≠da:", modelo.outputs[0].shape);
                
                setTimeout(() => atualizarProgresso(0), 2000);
                
            } catch (error) {
                console.error("Erro ao carregar modelo:", error);
                atualizarStatus("‚ùå Erro ao carregar o modelo. Verifique se os arquivos est√£o no local correto.", "error");
                atualizarProgresso(0);
            }
        }

        // Fun√ß√£o para processar arquivo NIfTI (agora manual)
        async function processarArquivoNifti(arquivo) {
            try {
                atualizarStatus("üìñ Lendo arquivo NIfTI...", "info", true);
                atualizarProgresso(25);

                const buffer = await arquivo.arrayBuffer();
                let dadosBuffer = buffer;

                // Descomprimir se for .nii.gz (usando pako, que precisar√° ser inclu√≠do novamente)
                if (arquivo.name.endsWith(".gz")) {
                    atualizarStatus("üì¶ Descomprimindo arquivo...", "info", true);
                    // Para usar pako, voc√™ precisar√° adicionar a linha de script novamente:
                    // <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
                    // E garantir que pako esteja dispon√≠vel globalmente.
                    // Por simplicidade, para esta vers√£o manual, vamos assumir .nii sem compress√£o.
                    throw new Error("Arquivos .nii.gz n√£o suportados nesta vers√£o simplificada. Por favor, use .nii");
                }

                atualizarProgresso(50);

                const header = readNiftiHeader(dadosBuffer);
                const imagemData = readNiftiImage(header, dadosBuffer);
                
                atualizarStatus("üîÑ Pr√©-processando dados...", "info", true);
                atualizarProgresso(75);

                console.log("Dimens√µes da imagem:", header.dims);
                console.log("Tipo de dados:", header.datatypeCode);

                return {
                    dados: imagemData,
                    header: header,
                    dimensoes: header.dims.slice(1, 4) // Remove a primeira dimens√£o (que √© sempre 0)
                };

            } catch (error) {
                console.error("Erro ao processar arquivo NIfTI:", error);
                throw error;
            }
        }

        // Fun√ß√£o para pr√©-processar os dados para o modelo
        function preprocessarDados(dados, dimensoes) {
            try {
                const [altura, largura, profundidade] = dimensoes;
                
                console.log("Dimens√µes originais da imagem NIfTI:", dimensoes);
                
                const fatiaMedia1 = Math.floor(profundidade * 0.4);
                const fatiaMedia2 = Math.floor(profundidade * 0.6);
                
                const fatia1 = new Float32Array(altura * largura);
                const fatia2 = new Float32Array(altura * largura);
                
                for (let i = 0; i < altura; i++) {
                    for (let j = 0; j < largura; j++) {
                        const idx2D = i * largura + j;
                        const idx3D1 = (fatiaMedia1 * altura * largura) + idx2D;
                        const idx3D2 = (fatiaMedia2 * altura * largura) + idx2D;
                        
                        fatia1[idx2D] = dados[idx3D1] || 0;
                        fatia2[idx2D] = dados[idx3D2] || 0;
                    }
                }

                let tensor1 = tf.tensor2d(fatia1, [altura, largura]);
                let tensor2 = tf.tensor2d(fatia2, [altura, largura]);

                if (altura !== 128 || largura !== 128) {
                    tensor1 = tf.image.resizeBilinear(tensor1.expandDims(2), [128, 128]).squeeze(2);
                    tensor2 = tf.image.resizeBilinear(tensor2.expandDims(2), [128, 128]).squeeze(2);
                }

                const min1 = tensor1.min();
                const max1 = tensor1.max();
                const min2 = tensor2.min();
                const max2 = tensor2.max();

                tensor1 = tensor1.sub(min1).div(max1.sub(min1).add(1e-8));
                tensor2 = tensor2.sub(min2).div(max2.sub(min2).add(1e-8));

                const tensorCombinado = tf.stack([tensor1, tensor2], 2);
                const tensorFinal = tensorCombinado.expandDims(0);

                console.log("Formato do tensor final para o modelo:", tensorFinal.shape);

                tensor1.dispose();
                tensor2.dispose();
                tensorCombinado.dispose();
                min1.dispose();
                max1.dispose();
                min2.dispose();
                max2.dispose();

                return tensorFinal;

            } catch (error) {
                console.error("Erro no pr√©-processamento:", error);
                throw error;
            }
        }

        // Fun√ß√£o para fazer a previs√£o e retornar a segmenta√ß√£o bruta
        async function fazerPrevisao(tensorEntrada) {
            try {
                atualizarStatus("üß† Executando an√°lise com IA...", "info", true);
                atualizarProgresso(90);

                const previsao = modelo.predict(tensorEntrada);
                
                const segmentacaoTensor = tf.argMax(previsao, -1);
                const segmentacaoArray = await segmentacaoTensor.data();

                previsao.dispose();
                segmentacaoTensor.dispose();

                const totalPixels = segmentacaoArray.length;
                const estatisticas = {
                    classe0: 0, // Background
                    classe1: 0, // Necrose
                    classe2: 0, // Edema
                    classe3: 0  // Tumor Real√ßado
                };

                for (let i = 0; i < totalPixels; i++) {
                    switch(segmentacaoArray[i]) {
                        case 0: estatisticas.classe0++; break;
                        case 1: estatisticas.classe1++; break;
                        case 2: estatisticas.classe2++; break;
                        case 3: estatisticas.classe3++; break;
                    }
                }

                const porcentagens = {
                    background: (estatisticas.classe0 / totalPixels * 100).toFixed(2),
                    necrose: (estatisticas.classe1 / totalPixels * 100).toFixed(2),
                    edema: (estatisticas.classe2 / totalPixels * 100).toFixed(2),
                    tumorRealcado: (estatisticas.classe3 / totalPixels * 100).toFixed(2)
                };

                return { porcentagens, segmentacaoArray, dimensoesSaida: [128, 128] };

            } catch (error) {
                console.error("Erro na previs√£o:", error);
                throw error;
            }
        }

        // Nova fun√ß√£o para desenhar a segmenta√ß√£o no canvas
        function desenharSegmentacao(segmentacaoArray, dimensoesSaida) {
            const [altura, largura] = dimensoesSaida;

            segmentationCanvas.width = largura;
            segmentationCanvas.height = altura;

            const imageData = ctx.createImageData(largura, altura);
            const data = imageData.data;

            const cores = [
                [0, 0, 0, 0],     // Classe 0: Background (transparente)
                [255, 0, 0, 255], // Classe 1: Necrose (vermelho)
                [0, 0, 255, 255], // Classe 2: Edema (azul)
                [0, 255, 0, 255]  // Classe 3: Tumor Real√ßado (verde)
            ];

            for (let i = 0; i < segmentacaoArray.length; i++) {
                const classe = segmentacaoArray[i];
                const cor = cores[classe];

                const pixelIndex = i * 4;
                data[pixelIndex] = cor[0];
                data[pixelIndex + 1] = cor[1];
                data[pixelIndex + 2] = cor[2];
                data[pixelIndex + 3] = cor[3];
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Fun√ß√£o para exibir resultados
        function exibirResultados(resultados) {
            const { porcentagens, segmentacaoArray, dimensoesSaida } = resultados;

            const html = `
                <div class="result-item">
                    <span class="result-label">üîµ Background:</span>
                    <span class="result-value">${porcentagens.background}%</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üî¥ Necrose:</span>
                    <span class="result-value">${porcentagens.necrose}%</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üü° Edema:</span>
                    <span class="result-value">${porcentagens.edema}%</span>
                </div>
                <div class="result-item">
                    <span class="result-label">üü¢ Tumor Real√ßado:</span>
                    <span class="result-value">${porcentagens.tumorRealcado}%</span>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 5px;">
                    <small style="color: #1976d2;">
                        <strong>Nota:</strong> Esta √© uma an√°lise automatizada para fins educacionais. 
                        Sempre consulte um profissional m√©dico para diagn√≥sticos precisos.
                    </small>
                </div>
            `;
            
            resultsContent.innerHTML = html;

            desenharSegmentacao(segmentacaoArray, dimensoesSaida);
        }

        // Event listener para upload de arquivo
        inputArquivo.addEventListener("change", async function(evento) {
            if (!modeloCarregado) {
                atualizarStatus("‚è≥ Aguarde o modelo terminar de carregar...", "error");
                return;
            }

            if (evento.target.files.length === 0) return;

            const arquivo = evento.target.files[0];
            
            try {
                atualizarStatus(`üìÅ Processando: ${arquivo.name}`, "info", true);
                
                const dadosProcessados = await processarArquivoNifti(arquivo);
                const tensorEntrada = preprocessarDados(dadosProcessados.dados, dadosProcessados.dimensoes);
                const resultados = await fazerPrevisao(tensorEntrada);
                
                exibirResultados(resultados);
                
                atualizarProgresso(100);
                atualizarStatus("‚úÖ An√°lise conclu√≠da com sucesso!", "success");
                
                setTimeout(() => atualizarProgresso(0), 3000);

            } catch (error) {
                console.error("Erro durante o processamento:", error);
                atualizarStatus(`‚ùå Erro: ${error.message}`, "error");
                atualizarProgresso(0);
                
                resultsContent.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 20px;">
                        <p><strong>Erro no processamento:</strong></p>
                        <p>${error.message}</p>
                        <p style="margin-top: 10px; font-size: 0.9em; color: #6c757d;">
                            Verifique se o arquivo √© um NIfTI v√°lido (.nii ou .nii.gz)
                        </p>
                    </div>
                `;
            }
        });

        // Inicia o carregamento do modelo quando a p√°gina carrega
        window.addEventListener("load", carregarModelo);

        // Log de informa√ß√µes do TensorFlow.js
        console.log("TensorFlow.js vers√£o:", tf.version.tfjs);
        console.log("Backend:", tf.getBackend());
    </script>
</body>
</html>
